{"version":3,"sources":["../src/enums.js"],"names":["experimentalEnumTypeToFlow","ctx","enumConfig","description","enumDeclaration","babelTypes","identifier","name","enumStringBody","enumValues","map","v","enumDefaultedMember","experimentalEnumsMap","genericTypeAnnotation","id","enumTypeToFlow","schema","enumsByName","combinedDescription","n","replace","join","unionTypeAnnotation","stringLiteralTypeAnnotation","builtinScalars","Boolean","String","DateTime","Date","ID","Int","Float","scalarTypeToFlow","underlyingType","scalars","errors","push"],"mappings":"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","sourcesContent":["// @flow\n/**\n * Both input & output types can have enums & scalars.\n */\nimport * as babelTypes from '@babel/types';\nimport type {BabelNodeFlowType} from '@babel/types';\nimport type {Context} from './types';\nimport {maybeAddDescriptionComment} from './utils';\nimport type {IntrospectionEnumType} from 'graphql/utilities/introspectionQuery';\n\nexport const experimentalEnumTypeToFlow = (\n    ctx: Context,\n    enumConfig: IntrospectionEnumType,\n    description: string,\n): BabelNodeFlowType => {\n    const enumDeclaration = babelTypes.enumDeclaration(\n        // pass id into generic type annotation\n        babelTypes.identifier(enumConfig.name),\n        babelTypes.enumStringBody(\n            enumConfig.enumValues.map((v) =>\n                babelTypes.enumDefaultedMember(babelTypes.identifier(v.name)),\n            ),\n        ),\n    );\n\n    if (ctx.experimentalEnumsMap) {\n        ctx.experimentalEnumsMap[enumConfig.name] = enumDeclaration;\n    }\n\n    return maybeAddDescriptionComment(\n        description,\n        babelTypes.genericTypeAnnotation(enumDeclaration.id),\n    );\n};\n\nexport const enumTypeToFlow = (\n    ctx: Context,\n    name: string,\n): BabelNodeFlowType => {\n    const enumConfig = ctx.schema.enumsByName[name];\n    let combinedDescription = enumConfig.enumValues\n        .map(\n            (n) =>\n                `- ${n.name}` +\n                (n.description\n                    ? '\\n\\n      ' + n.description.replace(/\\n/g, '\\n      ')\n                    : ''),\n        )\n        .join('\\n');\n    if (enumConfig.description) {\n        combinedDescription =\n            enumConfig.description + '\\n\\n' + combinedDescription;\n    }\n\n    return ctx.experimentalEnumsMap\n        ? experimentalEnumTypeToFlow(ctx, enumConfig, combinedDescription)\n        : maybeAddDescriptionComment(\n              combinedDescription,\n              babelTypes.unionTypeAnnotation(\n                  enumConfig.enumValues.map((n) =>\n                      babelTypes.stringLiteralTypeAnnotation(n.name),\n                  ),\n              ),\n          );\n};\n\nexport const builtinScalars: {[key: string]: string} = {\n    Boolean: 'boolean',\n    String: 'string',\n    DateTime: 'string',\n    Date: 'string',\n    ID: 'string',\n    Int: 'number',\n    Float: 'number',\n};\n\nexport const scalarTypeToFlow = (\n    ctx: Context,\n    name: string,\n): BabelNodeFlowType => {\n    if (builtinScalars[name]) {\n        return babelTypes.genericTypeAnnotation(\n            babelTypes.identifier(builtinScalars[name]),\n        );\n    }\n    const underlyingType = ctx.scalars[name];\n    if (underlyingType != null) {\n        return babelTypes.genericTypeAnnotation(\n            babelTypes.identifier(underlyingType),\n        );\n    }\n    ctx.errors.push(\n        `Unexpected scalar '${name}'! Please add it to the \"scalars\" argument at the callsite of 'generateFlowTypes()'.`,\n    );\n    return babelTypes.genericTypeAnnotation(\n        babelTypes.identifier(`UNKNOWN_SCALAR[\"${name}\"]`),\n    );\n};\n"],"file":"enums.js"}