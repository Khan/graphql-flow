{"version":3,"sources":["../src/index.js"],"names":["optionsToConfig","schema","definitions","options","errors","internalOptions","strictNullability","readOnlyArray","scalars","typeScript","fragments","forEach","def","kind","name","value","config","allObjectTypes","path","experimentalEnumsMap","experimentalEnums","undefined","FlowGenerationError","Error","constructor","join","messages","documentToFlowTypes","document","result","map","item","types","code","exportAllObjectTypes","extraTypes","codegenExtraTypes","typeName","isFragment","operation","response","variables","filter","Boolean","length","Object","keys","k"],"mappings":"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","sourcesContent":["/* eslint-disable no-console */\n/* flow-uncovered-file */\n// @flow\n/**\n * This tool generates flowtype definitions from graphql queries.\n *\n * It relies on `introspection-query.json` existing in this directory,\n * which is produced by running `./tools/graphql-flow/sendIntrospection.js`.\n */\nimport type {DefinitionNode, DocumentNode} from 'graphql';\n\nimport generate from '@babel/generator'; // eslint-disable-line flowtype-errors/uncovered\nimport {\n    generateFragmentType,\n    generateResponseType,\n} from './generateResponseType';\nimport {generateVariablesType} from './generateVariablesType';\nimport type {BabelNode} from '@babel/types';\n\nimport type {Context, Schema, GenerateConfig} from './types';\n\nconst optionsToConfig = (\n    schema: Schema,\n    definitions: $ReadOnlyArray<DefinitionNode>,\n    options?: GenerateConfig,\n    errors: Array<string> = [],\n): Context => {\n    const internalOptions = {\n        strictNullability: options?.strictNullability ?? true,\n        readOnlyArray: options?.readOnlyArray ?? true,\n        scalars: options?.scalars ?? {},\n        typeScript: options?.typeScript ?? false,\n    };\n    const fragments = {};\n    definitions.forEach((def) => {\n        if (def.kind === 'FragmentDefinition') {\n            fragments[def.name.value] = def;\n        }\n    });\n    const config = {\n        fragments,\n        schema,\n        errors,\n        allObjectTypes: null,\n        path: [],\n        experimentalEnumsMap: options?.experimentalEnums ? {} : undefined,\n        ...internalOptions,\n    };\n\n    return config;\n};\n\nexport class FlowGenerationError extends Error {\n    messages: Array<string>;\n    constructor(errors: Array<string>) {\n        super(`Graphql-flow type generation failed! ${errors.join('; ')}`);\n        this.messages = errors;\n    }\n}\n\nexport const documentToFlowTypes = (\n    document: DocumentNode,\n    schema: Schema,\n    options?: GenerateConfig,\n): $ReadOnlyArray<{\n    name: string,\n    typeName: string,\n    code: string,\n    isFragment?: boolean,\n    extraTypes: {[key: string]: string},\n    experimentalEnums: {[key: string]: string},\n}> => {\n    const errors: Array<string> = [];\n    const config = optionsToConfig(\n        schema,\n        document.definitions,\n        options,\n        errors,\n    );\n    const result = document.definitions\n        .map((item) => {\n            if (item.kind === 'FragmentDefinition') {\n                const name = item.name.value;\n                const types = {};\n                const code = `export type ${name} = ${generateFragmentType(\n                    schema,\n                    item,\n                    {\n                        ...config,\n                        path: [name],\n                        allObjectTypes: options?.exportAllObjectTypes\n                            ? types\n                            : null,\n                    },\n                )};`;\n\n                const extraTypes = codegenExtraTypes(types);\n                const experimentalEnums = codegenExtraTypes(\n                    config.experimentalEnumsMap || {},\n                );\n\n                return {\n                    name,\n                    typeName: name,\n                    code,\n                    isFragment: true,\n                    extraTypes,\n                    experimentalEnums,\n                };\n            }\n            if (\n                item.kind === 'OperationDefinition' &&\n                (item.operation === 'query' || item.operation === 'mutation') &&\n                item.name\n            ) {\n                const types = {};\n                const name = item.name.value;\n                const response = generateResponseType(schema, item, {\n                    ...config,\n                    path: [name],\n                    allObjectTypes: options?.exportAllObjectTypes\n                        ? types\n                        : null,\n                });\n                const variables = generateVariablesType(schema, item, {\n                    ...config,\n                    path: [name],\n                });\n\n                const typeName = `${name}Type`;\n                // TODO(jared): Maybe make this template configurable?\n                // We'll see what's required to get webapp on board.\n                const code = `export type ${typeName} = {|\\n    variables: ${variables},\\n    response: ${response}\\n|};`;\n\n                const extraTypes = codegenExtraTypes(types);\n                const experimentalEnums = codegenExtraTypes(\n                    config.experimentalEnumsMap || {},\n                );\n\n                return {name, typeName, code, extraTypes, experimentalEnums};\n            }\n        })\n        .filter(Boolean);\n    if (errors.length) {\n        throw new FlowGenerationError(errors);\n    }\n    return result;\n};\n\nfunction codegenExtraTypes(types: {[key: string]: BabelNode}): {\n    [key: string]: string,\n} {\n    const extraTypes: {[key: string]: string} = {};\n    Object.keys(types).forEach((k: string) => {\n        // eslint-disable-next-line flowtype-errors/uncovered\n        extraTypes[k] = generate(types[k]).code;\n    });\n    return extraTypes;\n}\n"],"file":"index.js"}