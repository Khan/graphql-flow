{"version":3,"sources":["../src/generateTypeFiles.js"],"names":["indexPrelude","regenerateCommand","generateTypeFileContents","fileName","schema","document","options","generatedDir","indexContents","files","addToIndex","filePath","typeName","typeScript","replace","newLine","path","basename","indexOf","lines","split","map","line","includes","join","generated","forEach","name","code","isFragment","extraTypes","experimentalEnums","targetFileName","typeFileName","targetPath","fileContents","splitTypes","Object","keys","enumNames","length","getGeneratedDir","generatedDirectory","isAbsolute","relative","process","cwd","dirname","generateTypeFiles","indexFile","fs","existsSync","mkdirSync","recursive","writeFileSync","readFileSync","key","fname","processPragmas","generateConfig","crawlConfig","rawSource","ignorePragma","generate","autogen","loosePragma","autogenStrict","pragma","noPragmas","strict","strictNullability"],"mappings":"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","sourcesContent":["// @flow\nimport type {DocumentNode} from 'graphql';\nimport type {GenerateConfig, CrawlConfig, Schema} from './types';\nimport fs from 'fs';\nimport path from 'path';\nimport {documentToFlowTypes} from '.';\n// eslint-disable-next-line flowtype-errors/uncovered\nimport {convert} from '@khanacademy/flow-to-ts/dist/convert.bundle';\n\nexport const indexPrelude = (regenerateCommand?: string): string => `// @flow\n//\n// AUTOGENERATED\n// NOTE: New response types are added to this file automatically.\n//       Outdated response types can be removed manually as they are deprecated.\n//${regenerateCommand ? '      To regenerate, run ' + regenerateCommand : ''}\n//\n\n`;\n\nexport const generateTypeFileContents = (\n    fileName: string,\n    schema: Schema,\n    document: DocumentNode,\n    options: GenerateConfig,\n    generatedDir: string,\n    indexContents: string,\n): {indexContents: string, files: {[key: string]: string}} => {\n    const files = {};\n\n    /// Write export for __generated__/index.js if it doesn't exist\n    const addToIndex = (filePath, typeName) => {\n        if (options.typeScript) {\n            // Typescript doesn't like file extensions\n            filePath = filePath.replace(/\\.js$/, '');\n        }\n        const newLine = `export type {${typeName}} from './${path.basename(\n            filePath,\n        )}';`;\n        if (indexContents.indexOf('./' + path.basename(filePath)) === -1) {\n            indexContents += newLine + '\\n';\n        } else {\n            const lines = indexContents.split('\\n').map((line) => {\n                if (line.includes('./' + path.basename(filePath))) {\n                    return newLine;\n                }\n                return line;\n            });\n            indexContents = lines.join('\\n');\n        }\n    };\n\n    const generated = documentToFlowTypes(document, schema, options);\n    generated.forEach(\n        ({name, typeName, code, isFragment, extraTypes, experimentalEnums}) => {\n            // We write all generated files to a `__generated__` subdir to keep\n            // things tidy.\n            const targetFileName = options.typeFileName\n                ? options.typeFileName.replace('[operationName]', name)\n                : `${name}.js`;\n            const targetPath = path.join(generatedDir, targetFileName);\n\n            let fileContents =\n                '// @' +\n                `flow\\n// AUTOGENERATED -- DO NOT EDIT\\n` +\n                `// Generated for operation '${name}' in file '../${path.basename(\n                    fileName,\n                )}'\\n` +\n                (options.regenerateCommand\n                    ? `// To regenerate, run '${options.regenerateCommand}'.\\n`\n                    : '') +\n                code;\n            if (options.splitTypes && !isFragment) {\n                fileContents +=\n                    `\\nexport type ${name} = ${typeName}['response'];\\n` +\n                    `export type ${name}Variables = ${typeName}['variables'];\\n`;\n            }\n            Object.keys(extraTypes).forEach(\n                (name) =>\n                    (fileContents += `\\n\\nexport type ${name} = ${extraTypes[name]};`),\n            );\n            const enumNames = Object.keys(experimentalEnums);\n            if (options.experimentalEnums && enumNames.length) {\n                // TODO(somewhatabstract, FEI-4172): Update to fixed eslint-plugin-flowtype\n                // and remove this disable.\n                fileContents += `\\n\\n/* eslint-disable no-undef */`;\n                enumNames.forEach(\n                    (name) =>\n                        (fileContents += `\\nexport ${experimentalEnums[name]};\\n`),\n                );\n                fileContents += `/* eslint-enable no-undef */`;\n            }\n\n            addToIndex(targetPath, typeName);\n            files[targetPath] =\n                fileContents\n                    // Remove whitespace from the ends of lines; babel's generate sometimes\n                    // leaves them hanging around.\n                    .replace(/\\s+$/gm, '') + '\\n';\n        },\n    );\n\n    return {files, indexContents};\n};\n\nconst getGeneratedDir = (fileName: string, options: GenerateConfig) => {\n    const generatedDirectory = options.generatedDirectory ?? '__generated__';\n    if (path.isAbsolute(generatedDirectory)) {\n        // fileName is absolute here, so we make it relative to cwd\n        // for more reasonable filenames.  We convert leading ..'s\n        // to `__` so this doesn't escape the output directory.\n        return path.join(\n            generatedDirectory,\n            path\n                .relative(process.cwd(), path.dirname(fileName))\n                .replace(/\\.\\.\\//g, '__/'),\n        );\n    } else {\n        return path.join(path.dirname(fileName), generatedDirectory);\n    }\n};\n\nexport const generateTypeFiles = (\n    fileName: string,\n    schema: Schema,\n    document: DocumentNode,\n    options: GenerateConfig,\n) => {\n    const generatedDir = getGeneratedDir(fileName, options);\n    const indexFile = path.join(\n        generatedDir,\n        'index' + (options.typeScript ? '.ts' : '.js'),\n    );\n\n    if (!fs.existsSync(generatedDir)) {\n        fs.mkdirSync(generatedDir, {recursive: true});\n    }\n    if (!fs.existsSync(indexFile)) {\n        fs.writeFileSync(indexFile, indexPrelude(options.regenerateCommand));\n    }\n\n    const {indexContents, files} = generateTypeFileContents(\n        fileName,\n        schema,\n        document,\n        options,\n        generatedDir,\n        fs.readFileSync(indexFile, 'utf8'),\n    );\n\n    fs.writeFileSync(indexFile, indexContents);\n    Object.keys(files).forEach((key) => {\n        let fname = key;\n        if (options.typeScript) {\n            // eslint-disable-next-line flowtype-errors/uncovered\n            files[key] = convert(files[key]).replace(\n                `variables: {}`,\n                `variables: Record<never, never>`,\n            );\n            fname = key.replace(/\\.js$/, '.ts');\n        }\n        fs.writeFileSync(fname, files[key]);\n    });\n\n    fs.writeFileSync(indexFile, indexContents);\n};\n\nexport const processPragmas = (\n    generateConfig: GenerateConfig,\n    crawlConfig: CrawlConfig,\n    rawSource: string,\n): {generate: boolean, strict?: boolean} => {\n    if (\n        crawlConfig.ignorePragma &&\n        rawSource.includes(crawlConfig.ignorePragma)\n    ) {\n        return {generate: false};\n    }\n\n    const autogen = crawlConfig.loosePragma\n        ? rawSource.includes(crawlConfig.loosePragma)\n        : false;\n    const autogenStrict = crawlConfig.pragma\n        ? rawSource.includes(crawlConfig.pragma)\n        : false;\n    const noPragmas = !crawlConfig.loosePragma && !crawlConfig.pragma;\n\n    if (autogen || autogenStrict || noPragmas) {\n        return {\n            generate: true,\n            strict: noPragmas\n                ? generateConfig.strictNullability\n                : autogenStrict || !autogen,\n        };\n    } else {\n        return {generate: false};\n    }\n};\n"],"file":"generateTypeFiles.js"}