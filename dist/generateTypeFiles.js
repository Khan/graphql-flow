"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processPragmas = exports.indexPrelude = exports.generateTypeFiles = exports.generateTypeFileContents = void 0;
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _ = require(".");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const indexPrelude = regenerateCommand => `// AUTOGENERATED
// NOTE: New response types are added to this file automatically.
//       Outdated response types can be removed manually as they are deprecated.
//${regenerateCommand ? "      To regenerate, run " + regenerateCommand : ""}
//

`;
exports.indexPrelude = indexPrelude;
const generateTypeFileContents = (fileName, schema, document, options, generatedDir, originalIndexContents) => {
  let indexContents = originalIndexContents;
  const files = {};

  /// Write export for __generated__/index.ts if it doesn't exist
  const addToIndex = (filePath, typeName) => {
    if (options.omitFileExtensions) {
      // Typescript doesn't like file extensions
      filePath = filePath.replace(/\.ts$/, "");
    }
    const newLine = `export type {${typeName}} from "./${_path.default.basename(filePath)}";`;
    if (!indexContents.includes(newLine)) {
      indexContents += newLine + "\n";
    }
  };
  const generated = (0, _.documentToFlowTypes)(document, schema, options);
  generated.forEach(({
    name,
    typeName,
    code,
    isFragment,
    extraTypes,
    experimentalEnums
  }) => {
    // We write all generated files to a `__generated__` subdir to keep
    // things tidy.
    const targetFileName = options.typeFileName ? options.typeFileName.replace("[operationName]", name) : `${name}.ts`;
    const targetPath = _path.default.join(generatedDir, targetFileName);
    let fileContents = `// AUTOGENERATED -- DO NOT EDIT\n` + `// Generated for operation '${name}' in file '../${_path.default.basename(fileName)}'\n` + (options.regenerateCommand ? `// To regenerate, run '${options.regenerateCommand}'.\n` : "") + code;
    if (options.splitTypes && !isFragment) {
      fileContents += `\nexport type ${name} = ${typeName}['response'];\n` + `export type ${name}Variables = ${typeName}['variables'];\n`;
    }
    Object.keys(extraTypes).forEach(name => fileContents += `\n\nexport type ${name} = ${extraTypes[name]};`);
    const enumNames = Object.keys(experimentalEnums);
    if (options.experimentalEnums && enumNames.length) {
      // TODO(somewhatabstract, FEI-4172): Update to fixed eslint-plugin-flowtype
      // and remove this disable.
      fileContents += `\n\n/* eslint-disable no-undef */`;
      enumNames.forEach(name => fileContents += `\nexport ${experimentalEnums[name]};\n`);
      fileContents += `/* eslint-enable no-undef */`;
    }
    addToIndex(targetPath, typeName);
    files[targetPath] = fileContents
    // Remove whitespace from the ends of lines; babel's generate sometimes
    // leaves them hanging around.
    .replace(/\s+$/gm, "") + "\n";
  });
  return {
    files,
    indexContents
  };
};
exports.generateTypeFileContents = generateTypeFileContents;
const getGeneratedDir = (fileName, options) => {
  var _options$generatedDir;
  const generatedDirectory = (_options$generatedDir = options.generatedDirectory) !== null && _options$generatedDir !== void 0 ? _options$generatedDir : "__generated__";
  if (_path.default.isAbsolute(generatedDirectory)) {
    // fileName is absolute here, so we make it relative to cwd
    // for more reasonable filenames.  We convert leading ..'s
    // to `__` so this doesn't escape the output directory.
    return _path.default.join(generatedDirectory, _path.default.relative(process.cwd(), _path.default.dirname(fileName)).replace(/\.\.\//g, "__/"));
  } else {
    return _path.default.join(_path.default.dirname(fileName), generatedDirectory);
  }
};
const generateTypeFiles = (fileName, schema, document, options, outputFiles) => {
  const generatedDir = getGeneratedDir(fileName, options);
  const indexFile = _path.default.join(generatedDir, "index.ts");
  if (!_fs.default.existsSync(generatedDir)) {
    _fs.default.mkdirSync(generatedDir, {
      recursive: true
    });
  }
  if (!outputFiles[indexFile]) {
    outputFiles[indexFile] = indexPrelude(options.regenerateCommand);
  }
  const {
    indexContents,
    files
  } = generateTypeFileContents(fileName, schema, document, options, generatedDir, outputFiles[indexFile]);

  // Write out files
  for (const [fname, content] of Object.entries(files)) {
    outputFiles[fname] = content;
  }

  // Write out index file
  outputFiles[indexFile] = indexContents;
  return outputFiles;
};
exports.generateTypeFiles = generateTypeFiles;
const processPragmas = (generateConfig, crawlConfig, rawSource) => {
  if (crawlConfig.ignorePragma && rawSource.includes(crawlConfig.ignorePragma)) {
    return {
      generate: false
    };
  }
  const autogen = crawlConfig.loosePragma ? rawSource.includes(crawlConfig.loosePragma) : false;
  const autogenStrict = crawlConfig.pragma ? rawSource.includes(crawlConfig.pragma) : false;
  const noPragmas = !crawlConfig.loosePragma && !crawlConfig.pragma;
  if (autogen || autogenStrict || noPragmas) {
    return {
      generate: true,
      strict: noPragmas ? generateConfig.strictNullability : autogenStrict || !autogen
    };
  } else {
    return {
      generate: false
    };
  }
};
exports.processPragmas = processPragmas;