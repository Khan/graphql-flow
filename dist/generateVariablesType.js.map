{"version":3,"sources":["../src/generateVariablesType.js"],"names":["inputObjectToFlow","ctx","name","inputObject","schema","inputObjectsByName","errors","push","babelTypes","stringLiteralTypeAnnotation","description","objectTypeAnnotation","inputFields","map","vbl","maybeOptionalObjectTypeProperty","inputRefToFlow","type","undefined","prop","objectTypeProperty","identifier","optional","inputRef","kind","_inputRefToFlow","ofType","result","nullableTypeAnnotation","genericTypeAnnotation","typeParameterInstantiation","JSON","stringify","variableToFlow","_variableToFlow","builtinScalars","value","enumsByName","customScalarType","scalars","generateVariablesType","item","variableObject","variableDefinitions","variable","code"],"mappings":"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","sourcesContent":["// @flow\nimport generate from '@babel/generator'; // eslint-disable-line flowtype-errors/uncovered\nimport type {\n    BabelNodeFlowType,\n    BabelNodeObjectTypeProperty,\n} from '@babel/types';\nimport * as babelTypes from '@babel/types';\nimport type {OperationDefinitionNode, TypeNode} from 'graphql/language/ast';\nimport type {IntrospectionInputTypeRef} from 'graphql/utilities/introspectionQuery';\nimport {builtinScalars, enumTypeToFlow, scalarTypeToFlow} from './enums';\nimport type {Context, Schema} from './types';\nimport {\n    liftLeadingPropertyComments,\n    maybeAddDescriptionComment,\n    transferLeadingComments,\n} from './utils';\n\nexport const inputObjectToFlow = (\n    ctx: Context,\n    name: string,\n): BabelNodeFlowType => {\n    const inputObject = ctx.schema.inputObjectsByName[name];\n    if (!inputObject) {\n        ctx.errors.push(`Unknown input object ${name}`);\n        return babelTypes.stringLiteralTypeAnnotation(\n            `Unknown input object ${name}`,\n        );\n    }\n\n    return maybeAddDescriptionComment(\n        inputObject.description,\n        babelTypes.objectTypeAnnotation(\n            inputObject.inputFields.map((vbl) =>\n                maybeAddDescriptionComment(\n                    vbl.description,\n                    maybeOptionalObjectTypeProperty(\n                        vbl.name,\n                        inputRefToFlow(ctx, vbl.type),\n                    ),\n                ),\n            ),\n            undefined /* indexers */,\n            undefined /* callProperties */,\n            undefined /* internalSlots */,\n            true /* exact */,\n        ),\n    );\n};\n\nexport const maybeOptionalObjectTypeProperty = (\n    name: string,\n    type: babelTypes.BabelNodeFlowType,\n): BabelNodeObjectTypeProperty => {\n    const prop = liftLeadingPropertyComments(\n        babelTypes.objectTypeProperty(babelTypes.identifier(name), type),\n    );\n    if (type.type === 'NullableTypeAnnotation') {\n        prop.optional = true;\n    }\n    return prop;\n};\n\nexport const inputRefToFlow = (\n    ctx: Context,\n    inputRef: IntrospectionInputTypeRef,\n): BabelNodeFlowType => {\n    if (inputRef.kind === 'NON_NULL') {\n        return _inputRefToFlow(ctx, inputRef.ofType);\n    }\n    const result = _inputRefToFlow(ctx, inputRef);\n    return transferLeadingComments(\n        result,\n        babelTypes.nullableTypeAnnotation(result),\n    );\n};\n\nconst _inputRefToFlow = (ctx: Context, inputRef: IntrospectionInputTypeRef) => {\n    if (inputRef.kind === 'SCALAR') {\n        return scalarTypeToFlow(ctx, inputRef.name);\n    }\n    if (inputRef.kind === 'ENUM') {\n        return enumTypeToFlow(ctx, inputRef.name);\n    }\n    if (inputRef.kind === 'INPUT_OBJECT') {\n        return inputObjectToFlow(ctx, inputRef.name);\n    }\n    if (inputRef.kind === 'LIST') {\n        return babelTypes.genericTypeAnnotation(\n            babelTypes.identifier('$ReadOnlyArray'),\n            babelTypes.typeParameterInstantiation([\n                inputRefToFlow(ctx, inputRef.ofType),\n            ]),\n        );\n    }\n    return babelTypes.stringLiteralTypeAnnotation(JSON.stringify(inputRef));\n};\n\nconst variableToFlow = (ctx: Context, type: TypeNode) => {\n    if (type.kind === 'NonNullType') {\n        return _variableToFlow(ctx, type.type);\n    }\n    const result = _variableToFlow(ctx, type);\n    return transferLeadingComments(\n        result,\n        babelTypes.nullableTypeAnnotation(result),\n    );\n};\n\nconst _variableToFlow = (ctx: Context, type: TypeNode) => {\n    if (type.kind === 'NamedType') {\n        if (builtinScalars[type.name.value]) {\n            return scalarTypeToFlow(ctx, type.name.value);\n        }\n        if (ctx.schema.enumsByName[type.name.value]) {\n            return enumTypeToFlow(ctx, type.name.value);\n        }\n        const customScalarType = ctx.scalars[type.name.value];\n        if (customScalarType) {\n            return babelTypes.genericTypeAnnotation(\n                babelTypes.identifier(customScalarType),\n            );\n        }\n        return inputObjectToFlow(ctx, type.name.value);\n    }\n    if (type.kind === 'ListType') {\n        return babelTypes.genericTypeAnnotation(\n            babelTypes.identifier('$ReadOnlyArray'),\n            babelTypes.typeParameterInstantiation([\n                variableToFlow(ctx, type.type),\n            ]),\n        );\n    }\n    return babelTypes.stringLiteralTypeAnnotation(\n        'UNKNOWN' + JSON.stringify(type),\n    );\n};\n\nexport const generateVariablesType = (\n    schema: Schema,\n    item: OperationDefinitionNode,\n    ctx: Context,\n): string => {\n    const variableObject = babelTypes.objectTypeAnnotation(\n        (item.variableDefinitions || []).map((vbl) => {\n            return maybeOptionalObjectTypeProperty(\n                vbl.variable.name.value,\n                variableToFlow(ctx, vbl.type),\n            );\n        }),\n        undefined /* indexers */,\n        undefined /* callProperties */,\n        undefined /* internalSlots */,\n        true /* exact */,\n    );\n    return generate(variableObject).code; // eslint-disable-line flowtype-errors/uncovered\n};\n"],"file":"generateVariablesType.js"}