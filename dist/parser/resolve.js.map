{"version":3,"sources":["../../src/parser/resolve.js"],"names":["resolveDocuments","files","resolved","errors","Object","keys","forEach","path","file","operations","op","resolveGqlTemplate","source","locals","k","local","type","resolveImport","expr","seen","push","loc","message","join","res","exports","name","value","template","key","line","map","expressions","length","literals","document","includes","raw"],"mappings":"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","sourcesContent":["// @flow\nimport gql from 'graphql-tag';\nimport type {DocumentNode} from 'graphql/language/ast';\nimport type {FileResult, Files, Import, Template, Document} from './parse';\n\nexport type Resolved = {\n    [key: string]: {\n        document: DocumentNode,\n        raw: Template,\n    },\n};\n\nexport const resolveDocuments = (\n    files: Files,\n): {resolved: Resolved, errors: FileResult['errors']} => {\n    const resolved: Resolved = {};\n    const errors: FileResult['errors'] = [];\n    Object.keys(files).forEach((path) => {\n        const file = files[path];\n        file.operations.forEach((op) => {\n            resolveGqlTemplate(op.source, files, errors, resolved, {});\n        });\n        Object.keys(file.locals).forEach((k) => {\n            const local = file.locals[k];\n            if (local.type === 'document') {\n                resolveGqlTemplate(local.source, files, errors, resolved, {});\n            }\n        });\n    });\n    return {resolved, errors};\n};\n\nconst resolveImport = (\n    expr: Import,\n    files: Files,\n    errors: FileResult['errors'],\n    seen: {[key: string]: true},\n): ?Document => {\n    if (seen[expr.path]) {\n        errors.push({\n            loc: expr.loc,\n            message: `Circular import ${Object.keys(seen).join(' -> ')} -> ${\n                expr.path\n            }`,\n        });\n        return null;\n    }\n    seen[expr.path] = true;\n    const res = files[expr.path];\n    if (!res) {\n        errors.push({loc: expr.loc, message: `No file ${expr.path}`});\n        return null;\n    }\n    if (!res.exports[expr.name]) {\n        errors.push({\n            loc: expr.loc,\n            message: `${expr.path} has no valid gql export ${expr.name}`,\n        });\n        return null;\n    }\n    const value = res.exports[expr.name];\n    if (value.type === 'import') {\n        return resolveImport(value, files, errors, seen);\n    }\n    return value;\n};\n\nconst resolveGqlTemplate = (\n    template: Template,\n    files: Files,\n    errors: FileResult['errors'],\n    resolved: Resolved,\n    seen: {[key: string]: Template},\n): ?DocumentNode => {\n    const key = template.loc.path + ':' + template.loc.line;\n    if (seen[key]) {\n        errors.push({\n            loc: template.loc,\n            message: `Recursive template dependency! ${Object.keys(seen)\n                .map(\n                    (k) =>\n                        k +\n                        ' ~ ' +\n                        seen[k].expressions.length +\n                        ',' +\n                        seen[k].literals.length,\n                )\n                .join(' -> ')} -> ${key}`,\n        });\n        return null;\n    }\n    seen[key] = template;\n    if (resolved[key]) {\n        return resolved[key].document;\n    }\n    const expressions = template.expressions.map((expr) => {\n        if (expr.type === 'import') {\n            const document = resolveImport(expr, files, errors, {});\n            return document\n                ? resolveGqlTemplate(document.source, files, errors, resolved, {\n                      ...seen,\n                  })\n                : null;\n        }\n        return resolveGqlTemplate(expr.source, files, errors, resolved, {\n            ...seen,\n        });\n    });\n    if (expressions.includes(null)) {\n        return null;\n    }\n    resolved[key] = {\n        document: gql(template.literals, ...expressions),\n        raw: template,\n    };\n    return resolved[key].document;\n};\n"],"file":"resolve.js"}