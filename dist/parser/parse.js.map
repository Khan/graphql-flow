{"version":3,"sources":["../../src/parser/parse.js"],"names":["listExternalReferences","file","paths","add","v","followImports","type","path","source","expressions","forEach","expr","Object","keys","exports","k","locals","operations","op","processFile","filePath","contents","dir","dirname","result","errors","resolved","resolvedPath","text","plugins","match","endsWith","filter","Boolean","enums","ast","sourceType","allowImportExportEverywhere","gqlTagNames","seenTemplates","program","body","toplevel","newLocals","getLocals","local","startsWith","name","push","importPath","value","resolve","join","specifiers","spec","exported","loc","start","end","line","processDeclarator","decl","isExported","id","init","tag","includes","tpl","processTemplate","document","declarations","declaration","visitTpl","node","getBinding","TaggedTemplateExpression","binding","scope","getTemplate","literals","quasi","quasis","map","q","cooked","message","found","myPath","importKind","imported","processFiles","filePaths","getFileSource","files","toProcess","slice","length","next","shift"],"mappings":"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","sourcesContent":["// @flow\nimport type {\n    BabelNodeImportDeclaration,\n    BabelNodeVariableDeclarator,\n    BabelNodeTaggedTemplateExpression,\n    BabelNodeFile,\n} from '@babel/types';\n\nimport {parse} from '@babel/parser'; // eslint-disable-line flowtype-errors/uncovered\nimport traverse from '@babel/traverse'; // eslint-disable-line flowtype-errors/uncovered\n\nimport path from 'path';\n\n/**\n * This file is responsible for finding all gql`-annotated\n * template strings in a set of provided files, and for resolving\n * all fragment references to their eventual sources.\n *\n * Things that are supported:\n * - importing fragments from other files\n * - re-exporting fragments that were imported\n * - using locally-defined fragments, even if they're\n *   not at the top level (scope is honored correctly)\n * - importing the gql tag as some other name\n * \t (e.g. 'import blah from \"graphql-tag\"')\n * - renaming fragments at the top level\n *\n * Things that are *not* supported:\n * - doing anything other than 'const x = gql`my template`'\n * \t e.g. const x = someCond ? one fragment literal : another fragment literal\n *   or const x = someFragmentPreprocessor(fragment literal)\n * - importing the graphql tag fn from anywhere other than \"graphql-tag\"\n * - anything else fancy with the graphql tag fn, e.g. 'const blah = gql; blah`xyz`'\n * - including a fragment in an operation by anything other than a bare identifier,\n *   e.g. 'const myQuery = gql`query xyz {...} ${cond ? someFrag : otherFrag}`.\n * - getting fragments from e.g. function arguments, or renaming non-toplevel fragments\n *\n * Things that could be supported, but are not yet:\n * - tracking whether a given graphql operation has already been wrapped\n *   in `gqlOp<Type>()` or not (to inform an auto-wrapper of the future)\n */\n\nexport type Template = {|\n    literals: Array<string>,\n    expressions: Array<Document | Import>,\n    loc: Loc,\n|};\nexport type Loc = {start: number, end: number, path: string, line: number};\n\nexport type Document = {|\n    type: 'document',\n    source: Template,\n|};\nexport type Import = {|\n    type: 'import',\n    name: string,\n    path: string,\n    loc: Loc,\n|};\n\nexport type Operation = {|\n    source: Template,\n    // TODO: Determine if an operation is already wrapped\n    // in `gqlOp` so we can automatically wrap if needed.\n    // needsWrapping: boolean,\n|};\n\nexport type FileResult = {|\n    path: string,\n    operations: Array<Operation>,\n    exports: {[key: string]: Document | Import},\n    locals: {[key: string]: Document | Import},\n    errors: Array<{loc: Loc, message: string}>,\n|};\n\nexport type Files = {[path: string]: FileResult};\n\n/**\n * Finds all referenced imports that might possibly be relevant\n * graphql fragments.\n *\n * Importantly, any values that are re-exported are treated as\n * potentially relevant, and of course any values referenced\n * from a graphql template are treated as relevant.\n */\nconst listExternalReferences = (file: FileResult): Array<string> => {\n    const paths = {};\n    const add = (v: Document | Import, followImports: boolean) => {\n        if (v.type === 'import') {\n            if (followImports) {\n                paths[v.path] = true;\n            }\n        } else {\n            v.source.expressions.forEach((expr) => add(expr, true));\n        }\n    };\n    Object.keys(file.exports).forEach((k) =>\n        add(\n            file.exports[k],\n            // If we're re-exporting something, we need to follow that import.\n            true,\n        ),\n    );\n    Object.keys(file.locals).forEach((k) =>\n        add(\n            file.locals[k],\n            // If we've imported something but haven't used it or exported it,\n            // we don't need to follow the import.\n            false,\n        ),\n    );\n    file.operations.forEach((op) =>\n        op.source.expressions.forEach((expr) =>\n            add(\n                expr,\n                // Imports that are used in graphql expressions definitely need to be followed.\n                true,\n            ),\n        ),\n    );\n    return Object.keys(paths);\n};\n\nexport const processFile = (\n    filePath: string,\n    contents: string | {text: string, resolvedPath: string},\n): FileResult => {\n    const dir = path.dirname(filePath);\n    const result: FileResult = {\n        path: filePath,\n        operations: [],\n        exports: {},\n        locals: {},\n        errors: [],\n    };\n    const resolved =\n        typeof contents === 'string' ? filePath : contents.resolvedPath;\n    const text = typeof contents === 'string' ? contents : contents.text;\n    const plugins = resolved.match(/\\.tsx?$/)\n        ? ['typescript', filePath.endsWith('x') ? 'jsx' : null].filter(Boolean)\n        : [['flow', {enums: true}], 'jsx'];\n    /* eslint-disable flowtype-errors/uncovered */\n    const ast: BabelNodeFile = parse(text, {\n        sourceType: 'module',\n        allowImportExportEverywhere: true,\n        plugins: plugins,\n    });\n    /* eslint-enable flowtype-errors/uncovered */\n    const gqlTagNames = [];\n    const seenTemplates: {[key: number]: Document | false} = {};\n\n    ast.program.body.forEach((toplevel) => {\n        if (toplevel.type === 'ImportDeclaration') {\n            const newLocals = getLocals(dir, toplevel, filePath);\n            if (newLocals) {\n                Object.keys(newLocals).forEach((k) => {\n                    const local = newLocals[k];\n                    if (local.path.startsWith('/')) {\n                        result.locals[k] = local;\n                    }\n                    if (\n                        local.path === 'graphql-tag' &&\n                        local.name === 'default'\n                    ) {\n                        gqlTagNames.push(k);\n                    }\n                });\n            }\n        }\n        if (toplevel.type === 'ExportNamedDeclaration') {\n            if (toplevel.source) {\n                const source = toplevel.source;\n                const importPath = source.value.startsWith('.')\n                    ? path.resolve(path.join(dir, source.value))\n                    : source.value;\n                toplevel.specifiers?.forEach((spec) => {\n                    if (\n                        spec.type === 'ExportSpecifier' &&\n                        spec.exported.type === 'Identifier'\n                    ) {\n                        result.exports[spec.exported.name] = {\n                            type: 'import',\n                            name: spec.local.name,\n                            path: importPath,\n                            loc: {\n                                start: spec.start ?? -1,\n                                end: spec.end ?? -1,\n                                line: spec.loc?.start.line ?? -1,\n                                path: filePath,\n                            },\n                        };\n                    }\n                });\n            } else {\n                toplevel.specifiers?.forEach((spec) => {\n                    if (spec.type === 'ExportSpecifier') {\n                        const local = result.locals[spec.local.name];\n                        if (local && spec.exported.type === 'Identifier') {\n                            result.exports[spec.exported.name] = local;\n                        }\n                    }\n                });\n            }\n        }\n\n        const processDeclarator = (\n            decl: BabelNodeVariableDeclarator,\n            isExported: boolean,\n        ) => {\n            if (decl.id.type !== 'Identifier' || !decl.init) {\n                return;\n            }\n            const {init} = decl;\n            const id = decl.id.name;\n            if (\n                init.type === 'TaggedTemplateExpression' &&\n                init.tag.type === 'Identifier'\n            ) {\n                if (gqlTagNames.includes(init.tag.name)) {\n                    const tpl = processTemplate(init, result);\n                    if (tpl) {\n                        const document = (result.locals[id] = {\n                            type: 'document',\n                            source: tpl,\n                        });\n                        seenTemplates[init.start ?? -1] = document;\n                        if (isExported) {\n                            result.exports[id] = document;\n                        }\n                    } else {\n                        seenTemplates[init.start ?? -1] = false;\n                    }\n                }\n            }\n            if (init.type === 'Identifier' && result.locals[init.name]) {\n                result.locals[id] = result.locals[init.name];\n                if (isExported) {\n                    result.exports[id] = result.locals[init.name];\n                }\n            }\n        };\n\n        if (toplevel.type === 'VariableDeclaration') {\n            toplevel.declarations.forEach((decl) => {\n                processDeclarator(decl, false);\n            });\n        }\n\n        if (\n            toplevel.type === 'ExportNamedDeclaration' &&\n            toplevel.declaration?.type === 'VariableDeclaration'\n        ) {\n            toplevel.declaration.declarations.forEach((decl) => {\n                processDeclarator(decl, true);\n            });\n        }\n    });\n\n    const visitTpl = (\n        node: BabelNodeTaggedTemplateExpression,\n        getBinding: (name: string) => Document | null,\n    ) => {\n        if (seenTemplates[node.start ?? -1] != null) {\n            return;\n        }\n        if (\n            node.tag.type !== 'Identifier' ||\n            !gqlTagNames.includes(node.tag.name)\n        ) {\n            return;\n        }\n        const tpl = processTemplate(node, result, getBinding);\n        if (tpl) {\n            seenTemplates[node.start ?? -1] = {type: 'document', source: tpl};\n            result.operations.push({\n                source: tpl,\n            });\n        } else {\n            seenTemplates[node.start ?? -1] = false;\n        }\n    };\n\n    /* eslint-disable flowtype-errors/uncovered */\n    traverse(ast, {\n        TaggedTemplateExpression(path) {\n            visitTpl(path.node, (name) => {\n                const binding = path.scope.getBinding(name);\n                const start = binding.path.node.init\n                    ? binding.path.node.init.start\n                    : null;\n                if (start && seenTemplates[start]) {\n                    return seenTemplates[start];\n                }\n                return null;\n            });\n        },\n    });\n    /* eslint-enable flowtype-errors/uncovered */\n\n    return result;\n};\n\nconst processTemplate = (\n    tpl: BabelNodeTaggedTemplateExpression,\n    result: FileResult,\n    getTemplate?: (name: string) => Document | null,\n    // getBinding?: (name: string) => Binding,\n    // seenTemplates,\n): ?Template => {\n    // 'cooked' is the string as runtime javascript will see it.\n    const literals = tpl.quasi.quasis.map((q) => q.value.cooked || '');\n    const expressions = tpl.quasi.expressions.map(\n        (expr): null | Document | Import => {\n            const loc: Loc = {\n                start: expr.start ?? -1,\n                end: expr.end ?? -1,\n                line: expr.loc?.start.line ?? -1,\n                path: result.path,\n            };\n            if (expr.type !== 'Identifier') {\n                result.errors.push({\n                    loc,\n                    message: `Template literal interpolation must be an identifier`,\n                });\n                return null;\n            }\n            if (!result.locals[expr.name]) {\n                if (getTemplate) {\n                    const found = getTemplate(expr.name);\n                    return found;\n                }\n                result.errors.push({\n                    loc,\n                    message: `Unable to resolve ${expr.name}`,\n                });\n                return null;\n            }\n            return result.locals[expr.name];\n        },\n    );\n    if (expressions.includes(null)) {\n        // bail, stop processing.\n        return;\n    }\n    return {\n        literals,\n        expressions: expressions.filter(Boolean),\n        loc: {\n            line: tpl.loc?.start.line ?? -1,\n            start: tpl.start ?? -1,\n            end: tpl.end ?? -1,\n            path: result.path,\n        },\n    };\n};\n\nconst getLocals = (\n    dir,\n    toplevel: BabelNodeImportDeclaration,\n    myPath: string,\n): ?{[key: string]: Import} => {\n    if (toplevel.importKind === 'type') {\n        return null;\n    }\n    const importPath = toplevel.source.value.startsWith('.')\n        ? path.resolve(path.join(dir, toplevel.source.value))\n        : toplevel.source.value;\n    const locals = {};\n    toplevel.specifiers.forEach((spec) => {\n        if (spec.type === 'ImportDefaultSpecifier') {\n            locals[spec.local.name] = {\n                type: 'import',\n                name: 'default',\n                path: importPath,\n                loc: {start: spec.start, end: spec.end, path: myPath},\n            };\n        } else if (spec.type === 'ImportSpecifier') {\n            locals[spec.local.name] = {\n                type: 'import',\n                name:\n                    spec.imported.type === 'Identifier'\n                        ? spec.imported.name\n                        : spec.imported.value,\n                path: importPath,\n                loc: {start: spec.start, end: spec.end, path: myPath},\n            };\n        }\n    });\n    return locals;\n};\n\nexport const processFiles = (\n    filePaths: Array<string>,\n    getFileSource: (\n        path: string,\n    ) => string | {text: string, resolvedPath: string},\n): Files => {\n    const files: Files = {};\n    const toProcess = filePaths.slice();\n    while (toProcess.length) {\n        const next = toProcess.shift();\n        if (files[next]) {\n            continue;\n        }\n        const result = processFile(next, getFileSource(next));\n        files[next] = result;\n        listExternalReferences(result).forEach((path) => {\n            if (!files[path] && !toProcess.includes(path)) {\n                toProcess.push(path);\n            }\n        });\n    }\n    return files;\n};\n"],"file":"parse.js"}