// @flow
// Import this in your jest setup, to mock out graphql-tag!
import type {DocumentNode} from 'graphql';
import type {Schema, Options, Scalars} from './';
import type {IntrospectionQuery} from 'graphql';

const generateTypeFiles = (
    schema: Schema,
    document: DocumentNode,
    scalars: Scalars,
    options: Options,
) => {
    const {documentToFlowTypes} = require('./');
    const path = require('path');
    const fs = require('fs');
    const format: ({text: string}) => string = require('prettier-eslint'); // flow-uncovered-line

    const indexFile = generatedDir => path.join(generatedDir, 'index.js');

    const maybeCreateGeneratedDir = generatedDir => {
        if (!fs.existsSync(generatedDir)) {
            fs.mkdirSync(generatedDir, {recursive: true});

            // Now write an index.js for each __generated__ dir.
            fs.writeFileSync(
                indexFile(generatedDir),
                '// @flow\n' +
                    '//\n' +
                    '// AUTOGENERATED\n' +
                    '// NOTE: New response types are added to this file automatically.\n' +
                    '//       Outdated response types can be removed manually as they are deprecated.\n' +
                    '//\n\n',
            );
        }
    };

    /// Write export for __generated__/index.js if it doesn't exist
    const writeToIndex = (filePath, typeName) => {
        const index = indexFile(path.dirname(filePath));
        const indexContents = fs.readFileSync(index);
        if (indexContents.indexOf(`export type {${typeName}}`) === -1) {
            fs.appendFileSync(
                index,
                `export type {${typeName}} from './${path.basename(
                    filePath,
                )}';\n`,
            );
        }
    };

    // Get the name of the file that `gql` was called from
    const errorLines = new Error().stack.split('\n');
    const fileName = errorLines[3]
        .split('(')
        .slice(-1)[0]
        .split(':')[0];

    documentToFlowTypes(document, schema, scalars, options).forEach(
        ({name, typeName, code}) => {
            // We write all generated files to a `__generated__` subdir to keep
            // things tidy.
            const targetFileName = `${typeName}.js`;
            const generatedDir = path.join(
                path.dirname(fileName),
                '__generated__',
            );
            const targetPath = path.join(generatedDir, targetFileName);

            maybeCreateGeneratedDir(generatedDir);

            // NOTE: Uncomment this to write the query definitions to disk if
            // you need to add new features to the flow type generation
            // fs.writeFileSync(
            //     targetFileName + '.query',
            //     JSON.stringify(definitions, null, 2),
            // );
            const fileContents = format({
                text:
                    '// @' +
                    `flow\n// AUTOGENERATED -- DO NOT EDIT\n` +
                    `// Generated for query '${name}' in file './${path.basename(
                        fileName,
                    )}'\n` +
                    `// To regenerate, run 'yarn test queries'.\n` +
                    code,
            });
            fs.writeFileSync(targetPath, fileContents);

            writeToIndex(targetPath, typeName);
        },
    );
};

type GraphqlTagFn = (raw: string, ...args: Array<any>) => DocumentNode;

// This function is expected to be called like so:
//
// jest.mock('graphql-tag', () => {
//     const introspectionData = jest.requireActual(
//         './our-introspection-query.json',
//     );
//
//     return jest.requireActual('graphql-flow/jest-mock-graphql-tag.js')(
//         introspectionData,
//     );
// });
//
// If both pragma and loosePragma are empty, then all graphql
// documents will be processed. Otherwise, only documents
// with one of the pragmas will be processed.
module.exports = (
    introspectionData: IntrospectionQuery,
    options: {
        pragma?: string,
        loosePragma?: string,
        scalars?: Scalars,
        strictNullability?: boolean,
        readOnlyArray?: boolean,
    } = {},
): GraphqlTagFn => {
    const collection = [];
    /* flow-uncovered-block */
    const print: DocumentNode => string = jest.requireActual(
        'graphql/language/printer',
    ).print;
    const addTypenameToDocument: DocumentNode => DocumentNode = jest.requireActual(
        'apollo-utilities',
    ).addTypenameToDocument;
    const schemaFromIntrospectionData: IntrospectionQuery => Schema = jest.requireActual(
        './',
    ).schemaFromIntrospectionData;
    const realGraphqlTag: GraphqlTagFn = jest.requireActual('graphql-tag');
    /* end flow-uncovered-block */

    const schema = schemaFromIntrospectionData(introspectionData);

    const wrapper = function gql() {
        const document: DocumentNode = realGraphqlTag.apply(this, arguments); // flow-uncovered-line
        const hasNonFragments = document.definitions.some(
            ({kind}) => kind !== 'FragmentDefinition',
        );
        if (hasNonFragments) {
            const withTypeNames: DocumentNode = addTypenameToDocument(document);
            collection.push(print(withTypeNames));

            const rawSource: string = arguments[0].raw[0]; // flow-uncovered-line

            const autogen = options.loosePragma
                ? rawSource.includes(options.loosePragma)
                : false;
            const autogenStrict = options.pragma
                ? rawSource.includes(options.pragma)
                : false;
            if (
                autogen ||
                autogenStrict ||
                (!options.loosePragma && !options.pragma)
            ) {
                // TODO(jared): Use withTypeNames here instead of document.
                generateTypeFiles(schema, document, options.scalars ?? {}, {
                    strictNullability: options.strictNullability,
                    readOnlyArray: options.readOnlyArray,
                });
            }
        }
        return document;
    };
    wrapper.collectedQueries = collection;
    return wrapper;
};
