import type {DocumentNode} from "graphql";
import type {GenerateConfig, CrawlConfig, Schema} from "./types";
import fs from "fs";
import path from "path";
import {documentToFlowTypes} from ".";

export const indexPrelude = (
    regenerateCommand?: string,
): string => `// AUTOGENERATED
// NOTE: New response types are added to this file automatically.
//       Outdated response types can be removed manually as they are deprecated.
//${regenerateCommand ? "      To regenerate, run " + regenerateCommand : ""}
//

`;

export const generateTypeFileContents = (
    fileName: string,
    schema: Schema,
    document: DocumentNode,
    options: GenerateConfig,
    generatedDir: string,
    originalIndexContents: string,
): {
    indexContents: string;
    files: {
        [key: string]: string;
    };
} => {
    let indexContents = originalIndexContents;
    const files: Record<string, any> = {};

    /// Write export for __generated__/index.ts if it doesn't exist
    const addToIndex = (filePath: string, typeName: unknown) => {
        if (options.omitFileExtensions) {
            // Typescript doesn't like file extensions
            filePath = filePath.replace(/\.ts$/, "");
        }
        const newLine = `export type {${typeName}} from "./${path.basename(
            filePath,
        )}";`;
        if (!indexContents.includes(newLine)) {
            indexContents += newLine + "\n";
        }
    };

    const generated = documentToFlowTypes(document, schema, options);
    generated.forEach(
        ({name, typeName, code, isFragment, extraTypes, experimentalEnums}) => {
            // We write all generated files to a `__generated__` subdir to keep
            // things tidy.
            const targetFileName = options.typeFileName
                ? options.typeFileName.replace("[operationName]", name)
                : `${name}.ts`;
            const targetPath = path.join(generatedDir, targetFileName);

            let fileContents =
                `// AUTOGENERATED -- DO NOT EDIT\n` +
                `// Generated for operation '${name}' in file '../${path.basename(
                    fileName,
                )}'\n` +
                (options.regenerateCommand
                    ? `// To regenerate, run '${options.regenerateCommand}'.\n`
                    : "") +
                code;
            if (options.splitTypes && !isFragment) {
                fileContents +=
                    `\nexport type ${name} = ${typeName}['response'];\n` +
                    `export type ${name}Variables = ${typeName}['variables'];\n`;
            }
            Object.keys(extraTypes).forEach(
                (name) =>
                    (fileContents += `\n\nexport type ${name} = ${extraTypes[name]};`),
            );
            const enumNames = Object.keys(experimentalEnums);
            if (options.experimentalEnums && enumNames.length) {
                // TODO(somewhatabstract, FEI-4172): Update to fixed eslint-plugin-flowtype
                // and remove this disable.
                fileContents += `\n\n/* eslint-disable no-undef */`;
                enumNames.forEach(
                    (name) =>
                        (fileContents += `\nexport ${experimentalEnums[name]};\n`),
                );
                fileContents += `/* eslint-enable no-undef */`;
            }

            addToIndex(targetPath, typeName);
            files[targetPath] =
                fileContents
                    // Remove whitespace from the ends of lines; babel's generate sometimes
                    // leaves them hanging around.
                    .replace(/\s+$/gm, "") + "\n";
        },
    );

    return {files, indexContents};
};

const getGeneratedDir = (fileName: string, options: GenerateConfig) => {
    const generatedDirectory = options.generatedDirectory ?? "__generated__";
    if (path.isAbsolute(generatedDirectory)) {
        // fileName is absolute here, so we make it relative to cwd
        // for more reasonable filenames.  We convert leading ..'s
        // to `__` so this doesn't escape the output directory.
        return path.join(
            generatedDirectory,
            path
                .relative(process.cwd(), path.dirname(fileName))
                .replace(/\.\.\//g, "__/"),
        );
    } else {
        return path.join(path.dirname(fileName), generatedDirectory);
    }
};

export const generateTypeFiles = (
    fileName: string,
    schema: Schema,
    document: DocumentNode,
    options: GenerateConfig,
    outputFiles: Record<string, string>,
) => {
    const generatedDir = getGeneratedDir(fileName, options);
    const indexFile = path.join(generatedDir, "index.ts");

    if (!fs.existsSync(generatedDir)) {
        fs.mkdirSync(generatedDir, {recursive: true});
    }
    if (!outputFiles[indexFile]) {
        outputFiles[indexFile] = indexPrelude(options.regenerateCommand);
    }

    const {indexContents, files} = generateTypeFileContents(
        fileName,
        schema,
        document,
        options,
        generatedDir,
        outputFiles[indexFile],
    );

    // Write out files
    for (const [fname, content] of Object.entries(files)) {
        outputFiles[fname] = content;
    }

    // Write out index file
    outputFiles[indexFile] = indexContents;

    return outputFiles;
};

export const processPragmas = (
    generateConfig: GenerateConfig,
    crawlConfig: CrawlConfig,
    rawSource: string,
): {
    generate: boolean;
    strict?: boolean;
} => {
    if (
        crawlConfig.ignorePragma &&
        rawSource.includes(crawlConfig.ignorePragma)
    ) {
        return {generate: false};
    }

    const autogen = crawlConfig.loosePragma
        ? rawSource.includes(crawlConfig.loosePragma)
        : false;
    const autogenStrict = crawlConfig.pragma
        ? rawSource.includes(crawlConfig.pragma)
        : false;
    const noPragmas = !crawlConfig.loosePragma && !crawlConfig.pragma;

    if (autogen || autogenStrict || noPragmas) {
        return {
            generate: true,
            strict: noPragmas
                ? generateConfig.strictNullability
                : autogenStrict || !autogen,
        };
    } else {
        return {generate: false};
    }
};
