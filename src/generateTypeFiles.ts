import type {DocumentNode} from 'graphql';
import type {GenerateConfig, CrawlConfig, Schema} from './types';
import fs from 'fs';
import path from 'path';
import {documentToFlowTypes} from '.';
// eslint-disable-next-line flowtype-errors/uncovered
import {convert} from '@khanacademy/flow-to-ts/dist/convert.bundle';

export const indexPrelude = (regenerateCommand?: string): string => `// @flow
//
// AUTOGENERATED
// NOTE: New response types are added to this file automatically.
//       Outdated response types can be removed manually as they are deprecated.
//${regenerateCommand ? '      To regenerate, run ' + regenerateCommand : ''}
//

`;

export const generateTypeFileContents = (
    fileName: string,
    schema: Schema,
    document: DocumentNode,
    options: GenerateConfig,
    generatedDir: string,
    indexContents: string,
): {
    indexContents: string
    files: {
        [key: string]: string
    }
} => {
    const files: Record<string, any> = {};

    /// Write export for __generated__/index.js if it doesn't exist
    const addToIndex = (filePath: string, typeName: unknown) => {
        if (options.typeScript || options.omitFileExtensions) {
            // Typescript doesn't like file extensions
            filePath = filePath.replace(/\.js$/, '');
        }
        const newLine = `export type {${typeName}} from './${path.basename(
            filePath,
        )}';`;
        // We match the entire new line to avoid issues that can arise from
        // prefix matches.
        if (indexContents.indexOf(newLine) === -1) {
            indexContents += newLine + '\n';
        }
    };

    const generated = documentToFlowTypes(document, schema, options);
    generated.forEach(
        ({name, typeName, code, isFragment, extraTypes, experimentalEnums}) => {
            // We write all generated files to a `__generated__` subdir to keep
            // things tidy.
            const targetFileName = options.typeFileName
                ? options.typeFileName.replace('[operationName]', name)
                : `${name}.js`;
            const targetPath = path.join(generatedDir, targetFileName);

            let fileContents =
                '// @' +
                `flow\n// AUTOGENERATED -- DO NOT EDIT\n` +
                `// Generated for operation '${name}' in file '../${path.basename(
                    fileName,
                )}'\n` +
                (options.regenerateCommand
                    ? `// To regenerate, run '${options.regenerateCommand}'.\n`
                    : '') +
                code;
            if (options.splitTypes && !isFragment) {
                fileContents +=
                    `\nexport type ${name} = ${typeName}['response'];\n` +
                    `export type ${name}Variables = ${typeName}['variables'];\n`;
            }
            Object.keys(extraTypes).forEach(
                (name) =>
                    (fileContents += `\n\nexport type ${name} = ${extraTypes[name]};`),
            );
            const enumNames = Object.keys(experimentalEnums);
            if (options.experimentalEnums && enumNames.length) {
                // TODO(somewhatabstract, FEI-4172): Update to fixed eslint-plugin-flowtype
                // and remove this disable.
                fileContents += `\n\n/* eslint-disable no-undef */`;
                enumNames.forEach(
                    (name) =>
                        (fileContents += `\nexport ${experimentalEnums[name]};\n`),
                );
                fileContents += `/* eslint-enable no-undef */`;
            }

            addToIndex(targetPath, typeName);
            files[targetPath] =
                fileContents
                    // Remove whitespace from the ends of lines; babel's generate sometimes
                    // leaves them hanging around.
                    .replace(/\s+$/gm, '') + '\n';
        },
    );

    return {files, indexContents};
};

const getGeneratedDir = (fileName: string, options: GenerateConfig) => {
    const generatedDirectory = options.generatedDirectory ?? '__generated__';
    if (path.isAbsolute(generatedDirectory)) {
        // fileName is absolute here, so we make it relative to cwd
        // for more reasonable filenames.  We convert leading ..'s
        // to `__` so this doesn't escape the output directory.
        return path.join(
            generatedDirectory,
            path
                .relative(process.cwd(), path.dirname(fileName))
                .replace(/\.\.\//g, '__/'),
        );
    } else {
        return path.join(path.dirname(fileName), generatedDirectory);
    }
};

export const generateTypeFiles = (
    fileName: string,
    schema: Schema,
    document: DocumentNode,
    options: GenerateConfig,
) => {
    const generatedDir = getGeneratedDir(fileName, options);
    const indexFile = path.join(
        generatedDir,
        'index' + (options.typeScript ? '.ts' : '.js'),
    );

    if (!fs.existsSync(generatedDir)) {
        fs.mkdirSync(generatedDir, {recursive: true});
    }
    if (!fs.existsSync(indexFile)) {
        fs.writeFileSync(indexFile, indexPrelude(options.regenerateCommand));
    }

    const {indexContents, files} = generateTypeFileContents(
        fileName,
        schema,
        document,
        options,
        generatedDir,
        fs.readFileSync(indexFile, 'utf8'),
    );

    fs.writeFileSync(indexFile, indexContents);
    Object.keys(files).forEach((key) => {
        let fname = key;
        if (options.typeScript) {
            // eslint-disable-next-line flowtype-errors/uncovered
            files[key] = convert(files[key]).replace(
                `variables: {}`,
                `variables: Record<never, never>`,
            );
            fname = key.replace(/\.js$/, '.ts');
        }
        fs.writeFileSync(fname, files[key]);
    });

    fs.writeFileSync(indexFile, indexContents);
};

export const processPragmas = (
    generateConfig: GenerateConfig,
    crawlConfig: CrawlConfig,
    rawSource: string,
): {
    generate: boolean
    strict?: boolean
} => {
    if (
        crawlConfig.ignorePragma &&
        rawSource.includes(crawlConfig.ignorePragma)
    ) {
        return {generate: false};
    }

    const autogen = crawlConfig.loosePragma
        ? rawSource.includes(crawlConfig.loosePragma)
        : false;
    const autogenStrict = crawlConfig.pragma
        ? rawSource.includes(crawlConfig.pragma)
        : false;
    const noPragmas = !crawlConfig.loosePragma && !crawlConfig.pragma;

    if (autogen || autogenStrict || noPragmas) {
        return {
            generate: true,
            strict: noPragmas
                ? generateConfig.strictNullability
                : autogenStrict || !autogen,
        };
    } else {
        return {generate: false};
    }
};
